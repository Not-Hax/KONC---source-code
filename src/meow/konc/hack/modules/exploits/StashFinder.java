package meow.konc.hack.modules.exploits;

import com.mojang.realmsclient.gui.ChatFormatting;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import meow.konc.hack.command.Command;
import meow.konc.hack.event.events.other.PacketEvent;
import meow.konc.hack.module.Module;
import meow.konc.hack.setting.Setting;
import meow.konc.hack.setting.Settings;
import net.minecraft.block.Block;
import net.minecraft.entity.Entity;
import net.minecraft.entity.passive.EntityDonkey;
import net.minecraft.init.Blocks;
import net.minecraft.init.SoundEvents;
import net.minecraft.network.play.server.SPacketSoundEffect;
import net.minecraft.tileentity.*;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.client.event.InputUpdateEvent;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;


@Module.Info(name = "StashFinder", category = Module.Category.EXPLOITS)
public class StashFinder extends Module {

    private Setting<Boolean> chest = register(Settings.b("Chests", true));
    private Setting<Boolean> echest = register(Settings.b("Ender Chests", true));
    private Setting<Boolean> shulker = register(Settings.b("Shulker boxes", true));
    private Setting<Boolean> donkey = register(Settings.b("Donkey", true));
    private Setting<Boolean> lightning = register(Settings.b("Thunders", false));
    private Setting<Boolean> bed = register(Settings.b("Bed", true));
    private Setting<Boolean> autowalk = register(Settings.b("AutoWalk", false));
    private Setting<Boolean> chat = register(Settings.b("Send Message", true));
    private HashMap<BlockPos, Integer> chests = new HashMap<>();
    private HashMap<BlockPos, Integer> shulkers = new HashMap<>();
    private HashMap<BlockPos, Integer> echests = new HashMap<>();
    private ArrayList<BlockPos> countedChests = new ArrayList<>();
    private ArrayList<BlockPos> countedEchests = new ArrayList<>();
    private ArrayList<BlockPos> countedShulkers = new ArrayList<>();
    private ArrayList<BlockPos> thunders = new ArrayList<>();
    private ArrayList<BlockPos> donkeys = new ArrayList<>();
    private ArrayList<BlockPos> beds = new ArrayList<>();
    @EventHandler
    public Listener<PacketEvent.Send> listener = new Listener<>(event -> {
        SPacketSoundEffect packet;
        BlockPos pos = null;
        if (lightning.getValue() && event.getPacket() instanceof SPacketSoundEffect) {
            packet = (SPacketSoundEffect) event.getPacket();
            if (packet.getCategory() == SoundCategory.WEATHER && packet.getSound() == SoundEvents.ENTITY_LIGHTNING_THUNDER) {
                pos.add(packet.getX(), packet.getY(), packet.getZ());
                thunders.add(pos);
                if (chat.getValue()) {
                    Command.sendChatMessage(ChatFormatting.RED.toString() + "Lightning spawned at X" + packet.getX() + " Z" + packet.getZ());
                }
            }
        }
    });

    @EventHandler
    private Listener<InputUpdateEvent> inputUpdateEventListener = new Listener<>(event -> {
        if (autowalk.getValue() && mc.player != null) {
            event.getMovementInput().moveForward = 1;
        }
    });

    @Override
    public void onUpdate() {
        int ccount = 0;
        int ecount = 0;
        int scount = 0;
        for (TileEntity tileEntity : mc.world.loadedTileEntityList) {
            BlockPos pos = tileEntity.getPos();
            if (tileEntity instanceof TileEntityChest && !chests.containsKey(pos) && !countedChests.contains(pos)) {
                final Iterable<BlockPos> posIterable = BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (mc.world.getBlockState(blockPos).getBlock() == Blocks.CHEST) {
                        countedChests.add(blockPos);
                        ccount++;
                    }
                }
                chests.put(pos, ccount);
                if (chat.getValue() && chest.getValue()) {
                    Command.sendChatMessage("Found " + ccount + "x chest at " + getFormattedBlockPos(pos));
                }
                ccount = 0;
            }
            if (tileEntity instanceof TileEntityEnderChest && !echests.containsKey(pos) && !countedEchests.contains(pos)) {
                final Iterable<BlockPos> posIterable = BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (mc.world.getBlockState(blockPos).getBlock() == Blocks.ENDER_CHEST) {
                        countedEchests.add(blockPos);
                        ecount++;
                    }
                }
                echests.put(pos, ecount);
                if (chat.getValue() && echest.getValue()) {
                    Command.sendChatMessage("Found " + ecount + "x echest at " + getFormattedBlockPos(pos));
                }
                ecount = 0;
            }
            if (tileEntity instanceof TileEntityShulkerBox && !shulkers.containsKey(pos) && !countedShulkers.contains(pos)) {
                final Iterable<BlockPos> posIterable = BlockPos.getAllInBox(pos.add(-12, -12, -12), pos.add(12, 12, 12));
                for (final BlockPos blockPos : posIterable) {
                    if (isShulkerBox(blockPos)) {
                        countedShulkers.add(blockPos);
                        scount++;
                    }
                }
                shulkers.put(pos, scount);
                if (chat.getValue() && shulker.getValue()) {
                    Command.sendChatMessage("Found " + scount + "x shulker at " + getFormattedBlockPos(pos));
                }
                scount = 0;
            }
            if (tileEntity instanceof TileEntityBed && !beds.contains(pos)) {
                beds.add(pos);
                if (chat.getValue() && bed.getValue()) {
                    Command.sendChatMessage("Found a bed at" + pos);
                }
            }
        }
        for (Entity entity : mc.world.loadedEntityList) {
            BlockPos pos2 = entity.getPosition();
            if (entity instanceof EntityDonkey && !donkeys.contains(pos2)) {
                donkeys.add(pos2);
                if (chat.getValue() && donkey.getValue()) {
                    Command.sendChatMessage("Found a donkey at" + pos2);
                }
            }
        }
    }

    @Override
    public void onDisable() {
        try {
            DateFormat df = new SimpleDateFormat("yy-MM-dd");
            DateFormat df2 = new SimpleDateFormat("HH-mm");
            DateFormat df3 = new SimpleDateFormat("yy/MM/dd");
            DateFormat df4 = new SimpleDateFormat("HH:mm");
            Date date = new Date();
            Date date2 = new Date();
            File file = new File("KONCMod/StashFinder/" + df.format(date) + " " + df2.format(date2) + ".txt");
            //SnowMod.stringManager.setUsername("StashFinder");
            //SnowMod.stringManager.setContent(mc.player.getName() + " " + df3.format(date) + " " + df4.format(date2) + " at " + Objects.requireNonNull(mc.getCurrentServerData()).serverIP);
            //SnowMod.stringManager.execute();
            if (!file.exists()) {
                file.getParentFile().mkdirs();
                try {
                    file.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            FileOutputStream fop = new FileOutputStream(file);
            OutputStreamWriter writer = new OutputStreamWriter(fop);
            thunders.forEach(blockPos -> {
                //SnowMod.stringManager.setContent("Thunder spawned at " + getFormattedBlockPos(blockPos));
                try {
                    //SnowMod.stringManager.execute();
                    if (lightning.getValue()) {
                        writer.append("Thunder spawned at ").append(getFormattedBlockPos(blockPos)).append("\n");
                    }
                } catch (IOException ignored) {
                }
            });
            beds.forEach(blockPos -> {
                //SnowMod.stringManager.setContent("bed at " + getFormattedBlockPos(blockPos));
                try {
                    //SnowMod.stringManager.execute();
                    if (bed.getValue()) {
                        writer.append("bed at ").append(getFormattedBlockPos(blockPos)).append("\n");
                    }
                } catch (IOException ignored) {
                }
            });

            chests.forEach((blockPos, integer) -> {
                //SnowMod.stringManager.setContent(integer.toString() + "x chest at " + getFormattedBlockPos(blockPos));
                try {
                    //SnowMod.stringManager.execute();
                    if (chest.getValue()) {
                        writer.append(integer.toString()).append("x chest at ").append(getFormattedBlockPos(blockPos)).append("\n");
                    }
                } catch (IOException ignored) {
                }
            });

            echests.forEach((blockPos, integer) -> {
                //SnowMod.stringManager.setContent(integer.toString() + "x echest at " + getFormattedBlockPos(blockPos));
                try {
                    //SnowMod.stringManager.execute();
                    if (echest.getValue()) {
                        writer.append(integer.toString()).append("x echest at ").append(getFormattedBlockPos(blockPos)).append("\n");
                    }
                } catch (IOException ignored) {
                }
            });

            shulkers.forEach((blockPos, integer) -> {
                //SnowMod.stringManager.setContent(integer.toString() + "x shulker at " + getFormattedBlockPos(blockPos));
                try {
                    //SnowMod.stringManager.execute();
                    if (shulker.getValue()) {
                        writer.append(integer.toString()).append("x shulker at ").append(getFormattedBlockPos(blockPos)).append("\n");
                    }
                } catch (IOException ignored) {
                }
            });

            donkeys.forEach(blockPos -> {
                //SnowMod.stringManager.setContent("donkey at " + getFormattedBlockPos(blockPos));
                try {
                    //SnowMod.stringManager.execute();
                    if (donkey.getValue()) {
                        writer.append("donkey at ").append(getFormattedBlockPos(blockPos)).append("\n");
                    }
                } catch (IOException ignored) {
                }
            });

            writer.close();
            fop.close();
            Command.sendChatMessage("File output succeed");
        } catch (IOException e) {
            Command.sendChatMessage("File output exception:" + e);
        } finally {
            beds.clear();
            chests.clear();
            donkeys.clear();
            shulkers.clear();
            echests.clear();
            countedEchests.clear();
            countedShulkers.clear();
            countedChests.clear();
        }
    }


    private String getFormattedBlockPos(BlockPos blockPos) {
        String done;
        done = blockPos.toString().replaceAll("BlockPos\\{", "");
        done = done.replaceAll("}", "");
        done = done.replaceAll("=", "= ");
        return done;
    }

    private Boolean isShulkerBox(BlockPos blockPos) {
        final List<Block> shulkerList = Arrays.asList(
                Blocks.WHITE_SHULKER_BOX,
                Blocks.ORANGE_SHULKER_BOX,
                Blocks.MAGENTA_SHULKER_BOX,
                Blocks.LIGHT_BLUE_SHULKER_BOX,
                Blocks.YELLOW_SHULKER_BOX,
                Blocks.LIME_SHULKER_BOX,
                Blocks.PINK_SHULKER_BOX,
                Blocks.GRAY_SHULKER_BOX,
                Blocks.SILVER_SHULKER_BOX,
                Blocks.CYAN_SHULKER_BOX,
                Blocks.PURPLE_SHULKER_BOX,
                Blocks.BLUE_SHULKER_BOX,
                Blocks.BROWN_SHULKER_BOX,
                Blocks.GREEN_SHULKER_BOX,
                Blocks.RED_SHULKER_BOX,
                Blocks.BLACK_SHULKER_BOX
        );
        return shulkerList.contains(mc.world.getBlockState(blockPos).getBlock());
    }
}
